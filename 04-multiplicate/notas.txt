Creamos la carpeta del proyecto
Ejecutamos el comando:
    * npm init -y
El package.json no es nesesaria para aplicaciones simples, en si nos sirve el archivo para crear una aplicacion ya estructurada en Node
Despues configuramos Typescript en el proyecto, siguiendo los pasos en:
    - https://gist.github.com/Klerith/47af527da090043f604b972b22dd4c01
        * De aqui configuramos nodemone (Aunque no lo requerimos en esta aplicacion)
            - Para no usar nodemon solo configuramos en el package.json en la parte de "dev"
                * "dev": "ts-node src/app.ts"
              Arriva es como lo configuramos y abajo pusimos una copia de respaldo del comando node:
                * "dev:nodemon": "nodemon"
              Esto lo hacemos asi porque como nos vamos a crear una aplicacion de consola eventualmente queremos mandarle argumentos que los mandariamos a llamar 
              como los comandos que ejecutamos en la terminal
        * Configuramos los comandos en el package.json para correr la aplicacion
Creamos el archivo y drectorio: app.ts
Levantamos la aplicacion: 
    - npm run dev
En salida de consola mostramos contenido, estas son herramientas que nos sirven para automatizar algun tipo de proceso, cuando se llaman por consola
muchas veses se requiere que podamos mandarle argumentos donde el comportamiento cambia segun las banderas que le pasemos o no
queremos que esta aplicacion de consola acepte banderas parametrizando todo lo que podamos parametrizar

Llamando al objeto "process" podemos acceder a las variables de entorno que son un monton "env" ademas podemos acceder
"argv" que es el de Arguments Value, al ejecutar con nodemon veremos los argv que fueron utilizados para ejcutar la aplicacion
Como estamos usando "ts-node" para ejecutar la  APP este es el primer argumento y como estamos ejecutando la aplicacion sale "app.ts"
(Estos son los argumentos que se mandaron de la parte de Node para ejecutarse)
Tenemos el comando del Build que nos crea el archivo de distribucion (Al ejecutar ese comando solo nos crea el directorio: "dist/app.js")
Esto lo podemos ejecutar directamente con el comando "node" no con ts-node como:
     node dist/app.js (El archivo es el mismo solo que es el de distribucion)
Ahora le podemos mandar una bandera
     node dist/app.js --base 10
No importa lo que le mandemos, la aplicacion los va a recibir pero no va a pasar nada porque no los esta esperando el programa
Estas son formas comunes de mandar argumentos
     node dist/app.js --base 10 -l=100 --file=hola.txt -s
Cuando empeizan dos lineas como --base es que es una palabra espacio un valor
con "-l" es el limite, este solo es un guion porque es la forma corta del argumento
El "--file" es considerado el "hola.txt" un string, igual se pueden poner comillas para poner espacios
"-s" es un valor booleano

Como prueba levantamos la aplicacion con:
    * npm run dev
Modificamos el "package.json" y en el comando "dev" mandamos al final "-b 10", con esto por defecto le estamos mandando la base de 10
entonces cada vez que ejecutemos el comando de arriba le estamos mandando estos argumentos por defecto
Ahora en el archivo "app.ts" vamos a tomar el valor de ese argumento

Para manejar todos estos datos facilmente tenemos la libreria de "Yargs", nosotros tenemos que analizar si vale la pena agregar un nuevo paquete al proyecto o 
vale la pena mejor programarlo nosotros.
Este paquete nos sirve para procesar los argumentos que recibimos y facilmente definir los comandos que queremos usar o las opciones, convertir el valor que recibimos
al tipo de dato que mandamos
Lo instalamos:
    * npm i yargs
Si queremos especificamente una version podemos indicarlo asi:
    * npm i yargs@17.1.1
Siguiendo las buenas practicas, NO QUEREMOS que nuestro proyecto dependa de este paquete si el dia de mañana queremos cambiar a otro paquete
para esto creamos el directorio
        - src/config/plugins
    Dentro creamos el archivo para el paquete pertinente
        - args.plugin.ts

El problema que tenemos en el archivo "app.logic.ts"
    El archivo no es Testeble ni mantenible porque tenemos altamente acopable todas las cosas y las piezas funcionales de la aplicacion, lo mejor es aplicar algun patron de arquitectura
    no importa cual, todas se basan en que el codigo sea escalable mantenible y entendible por personas en el futuro
        - Ya teniamos configurado el punto de entrada de nuestra aplicacion (Metodo "main" del archivo "app.ts")
        - Nos creamos la carpeta "presentation" esto es lo que vera el que consuma nuestra aplicacion, cuando trabajemos con servidores REST, aqui vamos a tener la parte de Express y vamos a tratar
          que cada capa cumpla un objetivo
        - El comando de Nodemon en el "package.json" le agregamos unos parametros en duro para poder ir probando la aplicacion
    Arquitectura limpia:
        Uno de los principales problemas que tienen las arquitecturas es que nos llenan de archivos, aqui como introduccion vamos a ver los casos de uso
            El software de cada de los casos de uso contiene las reglas de negocio especificas de la aplicacion
            condensa e implementa todos los casos de uso del sistema, estos casos de uso orquestan el flujo dentro
            y hacia las entidades

        Los casos de uso en nuestra aplicacion son: 
            - Crear la Tabla
            - Guardar los datos en un archivo de texto
        Debemos de detectar facilmente que puede cambiar el destino de los archivos, por tanto al caso de uso de guardar archivos
        debemos de mandarle el destino donde se quiere el archivo, con esto la funcion y el codigo 
        no deben de verse afectado solo por esa pequeña parte afectada