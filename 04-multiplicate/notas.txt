Creamos la carpeta del proyecto
Ejecutamos el comando:
    * npm init -y
El package.json no es nesesaria para aplicaciones simples, en si nos sirve el archivo para crear una aplicacion ya estructurada en Node
Despues configuramos Typescript en el proyecto, siguiendo los pasos en:
    - https://gist.github.com/Klerith/47af527da090043f604b972b22dd4c01
        * De aqui configuramos nodemone (Aunque no lo requerimos en esta aplicacion)
            - Para no usar nodemon solo configuramos en el package.json en la parte de "dev"
                * "dev": "ts-node src/app.ts"
              Arriva es como lo configuramos y abajo pusimos una copia de respaldo del comando node:
                * "dev:nodemon": "nodemon"
              Esto lo hacemos asi porque como nos vamos a crear una aplicacion de consola eventualmente queremos mandarle argumentos que los mandariamos a llamar 
              como los comandos que ejecutamos en la terminal
        * Configuramos los comandos en el package.json para correr la aplicacion
Creamos el archivo y drectorio: app.ts
Levantamos la aplicacion: 
    - npm run dev
En salida de consola mostramos contenido, estas son herramientas que nos sirven para automatizar algun tipo de proceso, cuando se llaman por consola
muchas veses se requiere que podamos mandarle argumentos donde el comportamiento cambia segun las banderas que le pasemos o no
queremos que esta aplicacion de consola acepte banderas parametrizando todo lo que podamos parametrizar

Llamando al objeto "process" podemos acceder a las variables de entorno que son un monton "env" ademas podemos acceder
"argv" que es el de Arguments Value, al ejecutar con nodemon veremos los argv que fueron utilizados para ejcutar la aplicacion
Como estamos usando "ts-node" para ejecutar la  APP este es el primer argumento y como estamos ejecutando la aplicacion sale "app.ts"
(Estos son los argumentos que se mandaron de la parte de Node para ejecutarse)
Tenemos el comando del Build que nos crea el archivo de distribucion (Al ejecutar ese comando solo nos crea el directorio: "dist/app.js")
Esto lo podemos ejecutar directamente con el comando "node" no con ts-node como:
     node dist/app.js (El archivo es el mismo solo que es el de distribucion)
Ahora le podemos mandar una bandera
     node dist/app.js --base 10
No importa lo que le mandemos, la aplicacion los va a recibir pero no va a pasar nada porque no los esta esperando el programa
Estas son formas comunes de mandar argumentos
     node dist/app.js --base 10 -l=100 --file=hola.txt -s
Cuando empeizan dos lineas como --base es que es una palabra espacio un valor
con "-l" es el limite, este solo es un guion porque es la forma corta del argumento
El "--file" es considerado el "hola.txt" un string, igual se pueden poner comillas para poner espacios
"-s" es un valor booleano

Como prueba levantamos la aplicacion con:
    * npm run dev
Modificamos el "package.json" y en el comando "dev" mandamos al final "-b 10", con esto por defecto le estamos mandando la base de 10
entonces cada vez que ejecutemos el comando de arriba le estamos mandando estos argumentos por defecto
Ahora en el archivo "app.ts" vamos a tomar el valor de ese argumento

Para manejar todos estos datos facilmente tenemos la libreria de "Yargs", nosotros tenemos que analizar si vale la pena agregar un nuevo paquete al proyecto o 
vale la pena mejor programarlo nosotros.
Este paquete nos sirve para procesar los argumentos que recibimos y facilmente definir los comandos que queremos usar o las opciones, convertir el valor que recibimos
al tipo de dato que mandamos
Lo instalamos:
    * npm i yargs
Si queremos especificamente una version podemos indicarlo asi:
    * npm i yargs@17.1.1
Siguiendo las buenas practicas, NO QUEREMOS que nuestro proyecto dependa de este paquete si el dia de ma√±ana queremos cambiar a otro paquete
para esto creamos el directorio
        - src/config/plugins
    Dentro creamos el archivo para el paquete pertinente
        - args.plugin.ts